%
% функция строит графики переходных процессов в линейной и нелинейной
% системах, замкнутых регулятором, найденым по линейному приближению.
% Системы описывают математическую модель простейшего электромагнитного
% подвеса.
%
function boat_control_driver

    % задаем время отрисовки графиков
    TIME = 10.0;
    % задаем ко-во точек, в которых нужно вычислять решение системы
    count = 201;
    

    % --------------------------------------------------------------------
    % ИССЛЕДУЕМ ИДЕАЛЬНЫЙ РЕГУЛЯТОР
    % --------------------------------------------------------------------  
    
    % задаем матрицы системы
    A = [0 1
        0 0];
    B = [0
        1];
    Q = [1 0
        0 0];

    %
    nx = size(A, 1);
    nu = size(B, 2);

    % находим стабилизирующий регулятор
    [~, ~, G] = care(A, B, Q);   
    
    % задаем параметры метода решения системы дифференциальных уравнений
    options = odeset('RelTol', 1e-5, 'AbsTol', 1e-5 * ones(1, nx));
    % задаем начальные условия 
    X0 = zeros(1, nx);   
    X0(1) = 0.2;
    
    % находим решение замкнутой линейной системы
    [tticks_ideal, xticks_ideal] = ode45(@(t, X)((A - B * G) * X), ...
        linspace(0, TIME, count), X0, options);     
    % вычисляем управление
    uticks_ideal = zeros(1, count);
    for k = 1 : count
        uticks_ideal(k) = -G * xticks_ideal(k, :)';
    end  


    % --------------------------------------------------------------------
    % ИССЛЕДУЕМ ИНЕРЦИОННЫЙ РЕГУЛЯТОР
    % --------------------------------------------------------------------    
    
    % задаем матрицы системы
    A = [0.0,  1.0,  0.0;
         0.0,  0.0,  1.0;
         0.0,  0.0,  0.0];
    B = [0.0;
         0.0;
         1.0];
    Q = [1.0,  0.0,  0.0;
         0.0,  0.0,  0.0;
         0.0,  0.0,  1.0];

    %
    nx = size(A, 1);
    nu = size(B, 2);

    % находим стабилизирующий регулятор
    [~, ~, G] = care(A, B, Q);    
    
    % задаем параметры метода решения системы дифференциальных уравнений
    options = odeset('RelTol', 1e-5, 'AbsTol', 1e-5 * ones(1, nx));
    % задаем начальные условия 
    X0 = zeros(1, nx);   
    X0(1) = 0.6;
    
    % находим решение замкнутой линейной системы
    [tticks_inertia, xticks_inertia] = ode45(@(t, X)((A - B * G) * X), ...
        linspace(0, TIME, count), X0, options);           
            
        
    % --------------------------------------------------------------------
	% СТРОИМ ГРАФИКИ РЕШЕНИЙ
    % --------------------------------------------------------------------  

    fhandle = figure;
    subplot(3, 1, 1)
        plot(tticks_ideal, xticks_ideal(:, 1), 'b', ...
             tticks_ideal, xticks_inertia(:, 1), 'r', 'LineWidth', 2.0)
        grid on;
        legend('безинерционный регулятор', 'инерционный регулятор');
        xlabel('t', 'FontSize', 12, 'FontWeight', 'bold');
        ylabel('x_1(t)', 'FontSize', 12, 'FontWeight', 'bold');
        title(sprintf('x_1^0 = %0.3f', X0(1)));
    subplot(3, 1, 2)
        plot(tticks_ideal, xticks_ideal(:, 2), 'b', ...
             tticks_ideal, xticks_inertia(:, 2), 'r', 'LineWidth', 2.0)
        grid on;
        legend('безинерционный регулятор', 'инерционный регулятор');
        xlabel('t', 'FontSize', 12, 'FontWeight', 'bold');
        ylabel('x_2(t)', 'FontSize', 12, 'FontWeight', 'bold');
        title(sprintf('x_2^0 = %0.3f', X0(2)));        
    subplot(3, 1, 3)
        plot(tticks_ideal, uticks_ideal, 'b', ...
             tticks_ideal, xticks_inertia(:, 3), 'r', 'LineWidth', 2.0)   
        grid on;
        legend('безинерционный регулятор', 'инерционный регулятор');
        xlabel('t', 'FontSize', 12, 'FontWeight', 'bold');
        ylabel('u(t)', 'FontSize', 12, 'FontWeight', 'bold');
        title(sprintf('x_3^0 = %0.3f', X0(3)));        
        
end

%
% вычисление значений функции, стоящей в правой части нелинейной
% системы дифференциальных уравнений
%
function F = nonlin_sys_cc(t, X, FB)

    % задаем параметры системы
    Kf  = 1.72579;
    Ks  = 4.48706;
    m   = 0.127;
    Ip  = 1.2e-3;
    lp  = 0.1778;
    M   = 1.2061;
    Beq = 5.40;
    Bp  = 2.4e-3;
    g   = 9.8;

    % вычисляем управление
    U = FB * X;
    % создаем вектор-столбец
    F = zeros(3, 1);
    %
    den = lp^2 * m^2 * cos(X(2))^2 - (Ip + lp^2 * m) * (m + M);
    % задаем значения компонент сформированного вектора
    F(1) = X(3);
    F(2) = X(4);
    F(3) = (Ip + lp^2 * m) * ((Beq + Kf * Ks) * X(3) - Kf * U + X(4)^2 * lp * m * sin(X(2))) + lp * m * cos(X(2)) * (Bp * X(4) - g * lp * m * sin(X(2)));
    F(3) = F(3) / den;
    F(4) = lp * m * cos(X(2)) * ((Beq + Kf * Ks) * X(3) - Kf * U + X(4)^2 * lp * m * sin(X(2))) + (m + M) * (Bp * X(4) - g * lp * m * sin(X(2)));
    F(4) = F(4) / den;
    
end 
